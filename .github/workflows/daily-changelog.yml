name: Gerar changelog di√°rio

on:
  workflow_dispatch: {}
  schedule:
    # Opcional: roda todo dia √†s 23:55 (UTC). Ajuste conforme necess√°rio ou remova a se√ß√£o schedule.
    - cron: "55 02 * * *"  # 23:55 hor√°rio de Bras√≠lia (UTC-3)


permissions:
  contents: write
  pull-requests: read
  metadata: read

jobs:
  changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checar reposit√≥rio
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for version bump detection

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Instalar depend√™ncias
        run: npm ci

      - name: Incrementar vers√£o
        id: version
        run: |
          node scripts/increment-version.js
          VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Vers√£o atualizada para: $VERSION"

      - name: Commit version update
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add package.json
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}"
            git push
          else
            echo "Nenhuma mudan√ßa de vers√£o para commitar"
          fi

      - name: Gerar e publicar changelog das √∫ltimas 24h
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // üîß Configura√ß√µes
            const LABELS = {
              breaking: 'breaking-change', // mude se voc√™ usa outro nome
              user: 'user-facing',
            };
            const BADGES = {
              breaking: 'üí• BREAKING',
              user: '‚ú® Usu√°rio',
            };

            // ‚è±Ô∏è Janela de 24h
            const now = new Date();
            const since = new Date(now.getTime() - 24*60*60*1000);
            const sinceISO = since.toISOString();
            const dateFmt = now.toISOString().slice(0,10);

            // Descobre default branch
            const { data: repoData } = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoData.default_branch;

            // Pequena ajuda
            const typeFromText = (text = '') => {
              const m = /^(feat|fix|docs|chore|refactor|perf|test|build|ci|style)(\(|:|!|\s)/i.exec(text);
              return m ? m[1].toLowerCase() : 'outros';
            };
            const hasLabel = (labelsArr, wanted) =>
              (labelsArr || []).some(l => (typeof l === 'string' ? l : l.name)?.toLowerCase() === wanted.toLowerCase());

            // 1) PRs mesclados nas √∫ltimas 24h
            const day = sinceISO.slice(0,10); // YYYY-MM-DD
            const prQuery = `repo:${owner}/${repo} is:pr is:merged merged:>=${day}`;
            const prSearch = await github.paginate(github.rest.search.issuesAndPullRequests, { q: prQuery, per_page: 100 });

            const mergedPRs = prSearch
              .filter(i => i.pull_request && i.closed_at && i.pull_request.merged_at)
              .filter(i => new Date(i.pull_request.merged_at) >= since)
              .map(i => {
                const labels = i.labels?.map(l => typeof l === 'string' ? l : l.name).filter(Boolean) || [];
                const flags = {
                  breaking: hasLabel(labels, LABELS.breaking),
                  user: hasLabel(labels, LABELS.user),
                };
                const badges = [
                  flags.breaking ? BADGES.breaking : null,
                  flags.user ? BADGES.user : null,
                ].filter(Boolean).join(' ');
                const decoratedTitle = badges ? `${badges} ‚Äî ${i.title}` : i.title;
                return {
                  number: i.number,
                  title: i.title,
                  decoratedTitle,
                  user: i.user?.login,
                  url: i.html_url,
                  mergedAt: i.pull_request.merged_at,
                  labels,
                  flags,
                };
              });

            // 2) Commits no default branch nas √∫ltimas 24h (tolerante a mensagens ruins)
            const commitsResp = await github.paginate(github.rest.repos.listCommits, {
              owner, repo, sha: defaultBranch, since: sinceISO, per_page: 100,
            });

            // Ignora merges de PR (para evitar duplicidade)
            const mergeShas = new Set();
            const prNumberRe = /Merge pull request #(\d+)/i;
            for (const c of commitsResp) {
              const m = c.commit.message.match(prNumberRe);
              if (m) mergeShas.add(c.sha);
            }

            // Mensagens "ruins"
            const badMsg = (msg = '') =>
              /^(wip|fix|update|updates|minor|small|ajuste|ajustes|misc|temp|test|teste)$/i.test(msg.trim());

            // (Opcional) mapeamento pasta ‚Üí componente exib√≠vel
            const componentByDir = {
              // 'apps/web': 'App Web',
              // 'packages/api': 'API',
            };

            async function summarizeCommit(c) {
              // 2.1 tenta achar PR associado
              const prsForCommit = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: c.sha
              });
              if (prsForCommit?.data?.length) {
                const pr = prsForCommit.data[0];
                // Aplica decora√ß√£o se o PR tiver labels
                const labels = pr.labels?.map(l => typeof l === 'string' ? l : l.name).filter(Boolean) || [];
                const flags = {
                  breaking: hasLabel(labels, LABELS.breaking),
                  user: hasLabel(labels, LABELS.user),
                };
                const badges = [
                  flags.breaking ? BADGES.breaking : null,
                  flags.user ? BADGES.user : null,
                ].filter(Boolean).join(' ');
                const decoratedTitle = badges ? `${badges} ‚Äî ${pr.title}` : pr.title;

                return {
                  kind: 'commit',
                  message: `PR #${pr.number} ‚Äì ${decoratedTitle} (via commit)`,
                  author: c.author?.login || c.commit?.author?.name || 'autor desconhecido',
                  url: pr.html_url,
                  inferredType: typeFromText(pr.title),
                  flags,
                };
              }

              // 2.2 Sem PR: sumariza pelo diff
              const files = await github.paginate(
                github.rest.repos.listCommitFiles,
                { owner, repo, commit_sha: c.sha, per_page: 100 }
              );

              const count = files.length;
              const byDir = {};
              const tags = new Set();

              for (const f of files) {
                const dir = (f.filename || '').split('/')[0] || '.';
                byDir[dir] = (byDir[dir] || 0) + 1;
                if (/^docs\//i.test(f.filename) || /README\.md$/i.test(f.filename)) tags.add('docs');
                if (/^test(s)?\//i.test(f.filename) || /\.spec\.|\.test\./i.test(f.filename)) tags.add('test');
                if (/package\.json|pnpm-lock|yarn\.lock/i.test(f.filename)) tags.add('deps');
                if (/migrat|migration|schema|sql/i.test(f.filename)) tags.add('db');
              }

              const topDirs = Object.entries(byDir)
                .sort((a,b)=>b[1]-a[1]).slice(0,3)
                .map(([d,n]) => `${componentByDir[d] || d} (${n})`).join(', ');

              const tagTxt = Array.from(tags).join(', ');
              const baseMsg = c.commit?.message?.split('\n')[0] || '';
              const readable = baseMsg && !badMsg(baseMsg)
                ? baseMsg
                : `Atualiza√ß√µes em ${count} arquivo(s) ‚Ä¢ √Åreas: ${topDirs}${tagTxt ? ` ‚Ä¢ Marcadores: ${tagTxt}` : ''}`;

              const inferredType =
                typeFromText(baseMsg) !== 'outros'
                  ? typeFromText(baseMsg)
                  : (tags.has('docs') ? 'docs' :
                     tags.has('test') ? 'test' :
                     'outros');

              return {
                kind: 'commit',
                message: `${readable}`, // sem emojis aqui (commits n√£o t√™m labels)
                author: c.author?.login || c.commit?.author?.name || 'autor desconhecido',
                url: c.html_url,
                inferredType,
                flags: {}, // sem flags sem PR
              };
            }

            const directCommits = await (async () => {
              const toSummarize = commitsResp.filter(c => !mergeShas.has(c.sha));
              const results = await Promise.all(toSummarize.map(summarizeCommit));
              return results;
            })();

            // 3) Buckets por tipo + captura de avisos
            const buckets = {
              feat: [], fix: [], docs: [], chore: [], refactor: [], perf: [], test: [], build: [], ci: [], style: [], outros: []
            };

            const importantNotices = []; // para se√ß√£o "Avisos importantes"

            // PRs (com emojis/avisos)
            for (const pr of mergedPRs) {
              const t = typeFromText(pr.title);
              const text = `PR #${pr.number} ‚Äì ${pr.decoratedTitle} (por @${pr.user})`;
              buckets[t] = buckets[t] || [];
              buckets[t].push({ kind: 'PR', text, url: pr.url });

              if (pr.flags.breaking || pr.flags.user) {
                const badges = [
                  pr.flags.breaking ? BADGES.breaking : null,
                  pr.flags.user ? BADGES.user : null,
                ].filter(Boolean).join(' ');
                importantNotices.push(`- ${badges} ‚Äî PR #${pr.number}: ${pr.title} ([link](${pr.url}))`);
              }
            }

            // Commits (tolerantes, sem labels ‚Üí sem avisos)
            for (const c of directCommits) {
              const t = c.inferredType || 'outros';
              buckets[t] = buckets[t] || [];
              buckets[t].push({ kind: 'commit', text: `${c.message} (por ${c.author})`, url: c.url });
            }

            // 4) Monta markdown leg√≠vel
            // Read current version from package.json
            let currentVersion = '0.5.0';
            try {
              const { data: pkgData } = await github.rest.repos.getContent({ owner, repo, path: 'package.json' });
              const pkgContent = Buffer.from(pkgData.content, pkgData.encoding || 'base64').toString('utf8');
              const pkg = JSON.parse(pkgContent);
              currentVersion = pkg.version || '0.5.0';
            } catch (e) {
              console.warn('Could not read version from package.json, using default');
            }
            
            const sectionTitle = `## [${currentVersion}] - ${dateFmt}`;

            const order = [
              ['feat','Novidades'],
              ['fix','Corre√ß√µes'],
              ['docs','Documenta√ß√£o'],
              ['perf','Desempenho'],
              ['refactor','Refatora√ß√µes'],
              ['build','Build'],
              ['ci','CI'],
              ['test','Testes'],
              ['style','Estilo'],
              ['chore','Tarefas'],
              ['outros','Outros']
            ];

            let body = '';

            // Se houver avisos importantes, mostra no topo
            if (importantNotices.length) {
              body += `\n### ‚ö†Ô∏è Avisos importantes\n`;
              body += importantNotices.join('\n') + '\n';
            }

            for (const [key, label] of order) {
              const items = buckets[key] || [];
              if (!items.length) continue;
              body += `\n### ${label}\n`;
              for (const it of items) {
                body += `- ${it.text} ([link](${it.url}))\n`;
              }
            }

            if (!body.trim()) {
              core.info('Nenhuma mudan√ßa relevante nas √∫ltimas 24h. Nada a fazer.');
              return;
            }

            const newSection = `${sectionTitle}\n${body}\n`;

            // 5) L√™ CHANGELOG.md, insere no topo e publica
            const path = 'CHANGELOG.md';
            let oldSha = undefined;
            let oldContent = '';
            try {
              const { data } = await github.rest.repos.getContent({ owner, repo, path });
              if (Array.isArray(data)) throw new Error('Esperado arquivo, veio diret√≥rio');
              oldSha = data.sha;
              const buff = Buffer.from(data.content, data.encoding || 'base64');
              oldContent = buff.toString('utf8');
            } catch (e) {
              // n√£o existe, cria do zero
              oldContent = '# Changelog\n\n';
            }

            const newContent = `${oldContent.startsWith('# Changelog') ? '' : '# Changelog\n\n'}${newSection}${oldContent.replace(/^# Changelog\n?\n?/,'')}`;

            if (newContent === oldContent) {
              core.info('Conte√∫do do changelog n√£o mudou. Pulando commit.');
              return;
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message: `docs(changelog): atualiza√ß√µes de ${dateFmt}`,
              content: Buffer.from(newContent, 'utf8').toString('base64'),
              sha: oldSha,
              branch: defaultBranch,
            });

            core.notice('Changelog atualizado com sucesso.');
